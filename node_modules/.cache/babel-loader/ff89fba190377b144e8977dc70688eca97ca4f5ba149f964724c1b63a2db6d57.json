{"ast":null,"code":"import React, { useState, useRef, useEffect } from 'react';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport * as pdfjsViewer from 'pdfjs-dist/web/pdf_viewer';\nimport { marked } from 'marked'; // 需要安装: npm install marked\nimport './styles/Reader.css';\nimport { pdfjs } from 'pdfjs-dist';\n\n// 设置 PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n\n// 全局变量定义\nwindow.currentPage = 1;\nwindow.totalPages = 0;\nwindow.changePage = null;\n\n// 添加全局事件跟踪对象\nwindow.eventTracker = window.eventTracker || {\n  mouseFollowHandlers: []\n};\n\n// 全局变量，确保在页面切换后仍然保持状态\nwindow.rhythmReaderGlobal = window.rhythmReaderGlobal || {\n  active: false,\n  speed: 300\n};\n\n// 节奏阅读模式 - 确保手动翻页后也能自动恢复\n(function () {\n  console.log(\"正在初始化节奏阅读模式...\");\n\n  // 确保只初始化一次\n  if (window.rhythmReadingInitialized) {\n    console.log(\"节奏阅读模式已经初始化过，跳过\");\n    return;\n  }\n  window.rhythmReadingInitialized = true;\n\n  // 改进的存储函数，同时使用session和local storage提高可靠性\n  function setStorage(key, value) {\n    try {\n      sessionStorage.setItem(key, value);\n      localStorage.setItem(key, value);\n    } catch (e) {\n      console.error(\"无法写入存储\", e);\n    }\n  }\n  function getStorage(key) {\n    try {\n      // 优先使用sessionStorage，这样更适合单次会话\n      return sessionStorage.getItem(key) || localStorage.getItem(key);\n    } catch (e) {\n      console.error(\"无法读取存储\", e);\n      return null;\n    }\n  }\n\n  // 状态变量和功能对象\n  const rhythmReader = {\n    active: false,\n    intervalId: null,\n    speed: 300,\n    currentIndex: 0,\n    readIndices: new Set(),\n    charElements: [],\n    pageTransitionInProgress: false,\n    // 初始化文本节点\n    initializeTextNodes: function () {\n      console.log(\"【节奏阅读】初始化文本节点...\");\n\n      // 重置字符元素数组\n      this.charElements = [];\n\n      // 获取内容容器\n      const contentContainer = document.querySelector('.page-content');\n      if (!contentContainer) {\n        console.error(\"【节奏阅读】找不到内容容器\");\n        return false;\n      }\n\n      // 查找所有文本节点并处理\n      const textNodes = [];\n      this.findTextNodes(contentContainer, textNodes);\n      if (textNodes.length === 0) {\n        console.error(\"【节奏阅读】未找到文本节点\");\n        this.showNotification(\"无法启动节奏阅读：未找到文本内容\");\n        return false;\n      }\n      console.log(`【节奏阅读】找到${textNodes.length}个文本节点`);\n\n      // 为每个文本节点创建字符span\n      textNodes.forEach(node => {\n        const text = node.nodeValue;\n        if (!text || text.trim() === '') return;\n\n        // 创建文档片段来存放字符span\n        const fragment = document.createDocumentFragment();\n\n        // 为每个字符创建span\n        for (let i = 0; i < text.length; i++) {\n          const char = text[i];\n          const span = document.createElement('span');\n          span.textContent = char;\n          span.className = 'rhythm-char';\n          span.dataset.rhythmIndex = String(this.charElements.length);\n\n          // 如果是空白字符，添加一个标志\n          if (char.trim() === '') {\n            span.dataset.whitespace = 'true';\n          }\n\n          // 保持原始样式，不设置背景\n          span.style.display = 'inline';\n          span.style.margin = '0';\n          span.style.padding = '0';\n          span.style.border = 'none';\n          span.style.backgroundColor = 'transparent';\n          fragment.appendChild(span);\n          this.charElements.push(span);\n        }\n\n        // 替换原始节点\n        if (node.parentNode) {\n          node.parentNode.replaceChild(fragment, node);\n        }\n      });\n      console.log(`【节奏阅读】总共创建${this.charElements.length}个字符span`);\n      return this.charElements.length > 0;\n    },\n    // 递归查找所有文本节点\n    findTextNodes: function (element, textNodes) {\n      // 处理子节点\n      for (let i = 0; i < element.childNodes.length; i++) {\n        const node = element.childNodes[i];\n\n        // 如果是文本节点且有内容\n        if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== '') {\n          textNodes.push(node);\n        }\n        // 如果是元素节点，递归处理\n        else if (node.nodeType === Node.ELEMENT_NODE) {\n          // 跳过读者UI元素\n          if (node.id === 'rhythm-speed-slider' || node.id === 'rhythm-notification' || node.className === 'rhythm-char') {\n            continue;\n          }\n          this.findTextNodes(node, textNodes);\n        }\n      }\n    },\n    // 更新文本颜色\n    updateTextColors: function () {\n      // 更新所有字符的颜色\n      this.charElements.forEach((span, index) => {\n        // 确定颜色\n        let color;\n        let fontWeight = 'inherit';\n        if (index === this.currentIndex) {\n          color = '#00aa00'; // 当前阅读的字 - 绿色\n          fontWeight = 'bold';\n        } else if (index === this.currentIndex + 1 || index === this.currentIndex + 2) {\n          color = '#aaaaaa'; // 接下来两个字 - 淡灰色\n        } else if (this.readIndices.has(index)) {\n          color = '#ffffff'; // 已读字符 - 白色（表示已读）\n        } else {\n          color = 'rgba(160, 160, 160, 0.25)'; // 未读字符 - 非常淡的灰色（可见但不明显）\n        }\n        span.style.color = color;\n        span.style.fontWeight = fontWeight;\n\n        // 确保没有背景\n        span.style.backgroundColor = 'transparent';\n        span.style.background = 'none';\n      });\n    },\n    // 移动到下一个字符\n    moveToNextChar: function () {\n      // 将当前字符标记为已读\n      this.readIndices.add(this.currentIndex);\n\n      // 移动到下一个非空白字符\n      do {\n        this.currentIndex++;\n\n        // 检查是否到达末尾\n        if (this.currentIndex >= this.charElements.length) {\n          console.log(\"【节奏阅读】已到达页尾，尝试翻页\");\n\n          // 尝试点击下一页按钮\n          if (!this.clickNextPageButton()) {\n            // 如果没有找到下一页按钮，完全停止阅读\n            this.stop();\n          }\n          return;\n        }\n      } while (this.currentIndex < this.charElements.length && this.charElements[this.currentIndex] && this.charElements[this.currentIndex].dataset.whitespace === 'true');\n\n      // 更新颜色\n      this.updateTextColors();\n\n      // 滚动到当前字符\n      this.scrollToCurrentChar();\n    },\n    // 滚动到当前字符\n    scrollToCurrentChar: function () {\n      const span = this.charElements[this.currentIndex];\n      if (!span) return;\n      const rect = span.getBoundingClientRect();\n      const contentContainer = document.querySelector('.page-content');\n\n      // 估计行高\n      const lineHeight = parseInt(window.getComputedStyle(span).lineHeight) || Math.max(20, rect.height * 1.5);\n\n      // 确定滚动容器\n      const isContainerScrollable = contentContainer && contentContainer.scrollHeight > contentContainer.clientHeight && ['auto', 'scroll', 'overlay'].includes(window.getComputedStyle(contentContainer).overflowY);\n      if (isContainerScrollable) {\n        // 容器滚动\n        const containerRect = contentContainer.getBoundingClientRect();\n        const relativeTop = rect.top - containerRect.top + contentContainer.scrollTop;\n        const visibleTop = contentContainer.scrollTop;\n        const visibleBottom = visibleTop + contentContainer.clientHeight;\n        if (relativeTop < visibleTop + lineHeight || relativeTop > visibleBottom - lineHeight) {\n          contentContainer.scrollBy({\n            top: lineHeight * 2 * (relativeTop > visibleBottom - lineHeight ? 1 : -1),\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // 窗口滚动\n        const viewportTop = window.scrollY;\n        const viewportBottom = viewportTop + window.innerHeight;\n        const absoluteTop = rect.top + window.scrollY;\n        if (absoluteTop < viewportTop + lineHeight || absoluteTop > viewportBottom - lineHeight) {\n          window.scrollBy({\n            top: lineHeight * 2 * (absoluteTop > viewportBottom - lineHeight ? 1 : -1),\n            behavior: 'smooth'\n          });\n        }\n      }\n    },\n    // 添加速度滑块\n    addSpeedSlider: function () {\n      let slider = document.getElementById('rhythm-speed-slider');\n      if (slider) slider.remove();\n      const container = document.createElement('div');\n      container.id = 'rhythm-speed-slider';\n      container.style.position = 'fixed';\n      container.style.top = '70px';\n      container.style.right = '20px';\n      container.style.backgroundColor = 'white';\n      container.style.padding = '10px';\n      container.style.borderRadius = '5px';\n      container.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';\n      container.style.zIndex = '10000';\n      container.style.display = 'flex';\n      container.style.alignItems = 'center';\n      container.style.maxWidth = '300px';\n      const label = document.createElement('label');\n      label.textContent = '速度: ';\n      label.style.marginRight = '8px';\n      container.appendChild(label);\n      const input = document.createElement('input');\n      input.type = 'range';\n      input.min = '50';\n      input.max = '1000';\n      input.step = '50';\n      input.value = this.speed;\n      input.style.width = '120px';\n      const valueDisplay = document.createElement('span');\n      valueDisplay.textContent = `${this.speed}ms`;\n      valueDisplay.style.marginLeft = '8px';\n      valueDisplay.style.minWidth = '60px';\n      const self = this;\n      input.addEventListener('input', function () {\n        const newSpeed = parseInt(this.value);\n        self.speed = newSpeed;\n        valueDisplay.textContent = `${newSpeed}ms`;\n        if (self.intervalId) {\n          clearInterval(self.intervalId);\n          self.intervalId = setInterval(() => self.moveToNextChar(), newSpeed);\n        }\n      });\n      container.appendChild(input);\n      container.appendChild(valueDisplay);\n      document.body.appendChild(container);\n    },\n    // 恢复原始文本\n    restoreOriginalText: function () {\n      // 获取所有已创建的字符span\n      const charSpans = document.querySelectorAll('.rhythm-char');\n\n      // 按父节点分组\n      const parentNodeMap = new Map();\n      charSpans.forEach(span => {\n        const parent = span.parentNode;\n        if (!parent) return;\n        if (!parentNodeMap.has(parent)) {\n          parentNodeMap.set(parent, []);\n        }\n        parentNodeMap.get(parent).push(span);\n      });\n\n      // 对每个父节点，将连续的字符span合并回文本节点\n      parentNodeMap.forEach((spans, parent) => {\n        if (spans.length === 0) return;\n\n        // 排序spans确保顺序正确\n        spans.sort((a, b) => {\n          const indexA = parseInt(a.dataset.rhythmIndex || '0');\n          const indexB = parseInt(b.dataset.rhythmIndex || '0');\n          return indexA - indexB;\n        });\n\n        // 根据连续性分组\n        const groups = [];\n        if (spans.length > 0) {\n          let currentGroup = [spans[0]];\n          for (let i = 1; i < spans.length; i++) {\n            const prevIndex = parseInt(spans[i - 1].dataset.rhythmIndex || '0');\n            const currentIndex = parseInt(spans[i].dataset.rhythmIndex || '0');\n            if (currentIndex === prevIndex + 1 && spans[i].previousSibling === spans[i - 1]) {\n              currentGroup.push(spans[i]);\n            } else {\n              groups.push(currentGroup);\n              currentGroup = [spans[i]];\n            }\n          }\n          groups.push(currentGroup);\n        }\n\n        // 对每个连续组替换为文本节点\n        groups.forEach(group => {\n          if (group.length === 0) return;\n          try {\n            const text = group.map(span => span.textContent).join('');\n            const textNode = document.createTextNode(text);\n\n            // 替换第一个span，然后移除其余的\n            if (group[0].parentNode === parent) {\n              parent.replaceChild(textNode, group[0]);\n              for (let i = 1; i < group.length; i++) {\n                if (group[i].parentNode === parent) {\n                  parent.removeChild(group[i]);\n                }\n              }\n            }\n          } catch (e) {\n            console.error(\"【节奏阅读】恢复文本时出错:\", e);\n          }\n        });\n      });\n\n      // 清除字符元素数组\n      this.charElements = [];\n    },\n    // 启动节奏阅读\n    start: function () {\n      console.log(\"【节奏阅读】启动中...\");\n\n      // 检查是否正在进行页面转换\n      if (this.pageTransitionInProgress) {\n        console.log(\"【节奏阅读】页面转换正在进行中，延迟启动\");\n        setTimeout(() => this.start(), 500);\n        return;\n      }\n\n      // 先停止已有的\n      this.stop(false);\n\n      // 设置为活动状态\n      this.active = true;\n      setStorage('rhythmReadingActive', 'true');\n\n      // 初始化文本\n      if (!this.initializeTextNodes()) {\n        console.error(\"【节奏阅读】无法初始化文本节点\");\n        return;\n      }\n\n      // 重要：始终从头开始阅读\n      this.currentIndex = 0;\n      this.readIndices.clear();\n\n      // 添加速度滑块\n      this.addSpeedSlider();\n\n      // 更新颜色\n      this.updateTextColors();\n\n      // 滚动到开始位置\n      this.scrollToCurrentChar();\n\n      // 设置阅读间隔\n      this.intervalId = setInterval(() => this.moveToNextChar(), this.speed);\n      console.log(\"【节奏阅读】成功启动\");\n\n      // 显示提示\n      this.showNotification(\"节奏阅读模式已启动\");\n\n      // 劫持翻页函数 - 重要步骤\n      this.hijackPageTurningFunctions();\n\n      // 设置页面导航事件监听\n      this.setupPageNavigationListeners();\n    },\n    // 停止节奏阅读\n    stop: function (showNotification = true) {\n      if (this.intervalId) {\n        clearInterval(this.intervalId);\n        this.intervalId = null;\n      }\n      if (this.active) {\n        console.log(\"【节奏阅读】停止中...\");\n        this.active = false;\n\n        // 仅当不是因翻页而停止时才清除活动状态\n        if (!this.pageTransitionInProgress) {\n          setStorage('rhythmReadingActive', 'false');\n        }\n\n        // 恢复原始文本\n        this.restoreOriginalText();\n\n        // 移除速度滑块\n        const slider = document.getElementById('rhythm-speed-slider');\n        if (slider) slider.remove();\n        if (showNotification) {\n          this.showNotification(\"节奏阅读模式已停止\");\n        }\n      }\n    },\n    // 显示通知\n    showNotification: function (message) {\n      let notification = document.getElementById('rhythm-notification');\n      if (notification) notification.remove();\n      notification = document.createElement('div');\n      notification.id = 'rhythm-notification';\n      notification.textContent = message;\n      notification.style.position = 'fixed';\n      notification.style.top = '50%';\n      notification.style.left = '50%';\n      notification.style.transform = 'translate(-50%, -50%)';\n      notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n      notification.style.color = 'white';\n      notification.style.padding = '15px 25px';\n      notification.style.borderRadius = '5px';\n      notification.style.zIndex = '10001';\n      notification.style.fontSize = '18px';\n      document.body.appendChild(notification);\n\n      // 2秒后自动消失\n      setTimeout(() => {\n        if (notification && notification.parentNode) {\n          notification.parentNode.removeChild(notification);\n        }\n      }, 2000);\n    },\n    // 劫持页面翻转函数 - 改进版本\n    hijackPageTurningFunctions: function () {\n      if (typeof window.changePage === 'function' && !window._originalChangePage) {\n        console.log(\"【节奏阅读】劫持changePage函数\");\n        window._originalChangePage = window.changePage;\n        const self = this;\n        window.changePage = function (page) {\n          console.log(\"【节奏阅读】检测到changePage调用，参数:\", page);\n          const wasActive = self.active;\n          self.pageTransitionInProgress = true;\n          if (wasActive) {\n            self.stop(false);\n            setStorage('rhythmReadingActive', 'true');\n            setStorage('rhythmReadingPending', 'true');\n            document.body.dataset.rhythmReadingActive = 'true';\n          }\n          try {\n            if (page === undefined || page === null) {\n              console.warn('【节奏阅读】安全处理：page参数为空');\n              page = {};\n            }\n            if (typeof page === 'object' && !page.something) {\n              console.log('【节奏阅读】添加空的something对象防止错误');\n              page.something = {\n                active: false\n              };\n            }\n            window._originalChangePage(page);\n          } catch (err) {\n            console.error(\"【节奏阅读】翻页函数执行出错:\", err);\n            self.clickNextPageButton();\n          }\n          setTimeout(() => {\n            self.pageTransitionInProgress = false;\n            if (wasActive && getStorage('rhythmReadingPending') === 'true') {\n              setStorage('rhythmReadingPending', 'false');\n              console.log(\"【节奏阅读】翻页后重新启动\");\n              setTimeout(() => self.start(), 500);\n            }\n          }, 1000);\n        };\n      }\n    },\n    // 设置页面导航事件监听 - 加强版\n    setupPageNavigationListeners: function () {\n      // 查找所有可能的翻页按钮\n      console.log(\"【节奏阅读】正在设置页面导航监听\");\n      const self = this;\n\n      // 使用事件委托来捕获所有可能的点击\n      document.addEventListener('click', function (e) {\n        // 检查点击的元素是否可能是翻页按钮\n        let target = e.target;\n        while (target && target !== document.body) {\n          // 检查是否是翻页元素\n          if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.getAttribute('role') === 'button') {\n            const text = (target.textContent || '').trim().toLowerCase();\n            const ariaLabel = (target.getAttribute('aria-label') || '').toLowerCase();\n\n            // 检查是否是翻页元素\n            if (text.includes('上一页') || text.includes('下一页') || text.includes('prev') || text.includes('next') || ariaLabel.includes('page') || ariaLabel.includes('页') || text === '<' || text === '>' || text === '←' || text === '→') {\n              if (self.active) {\n                console.log(`【节奏阅读】检测到可能的翻页元素点击: ${text || ariaLabel}`);\n\n                // 标记页面转换开始\n                self.pageTransitionInProgress = true;\n\n                // 保存状态到存储\n                setStorage('rhythmReadingActive', 'true');\n                setStorage('rhythmReadingPending', 'true');\n                document.body.dataset.rhythmReadingActive = 'true';\n\n                // 停止当前的阅读\n                self.stop(false);\n\n                // 添加延迟执行的监听器，确保数据在页面加载后恢复\n                setTimeout(() => {\n                  self.pageTransitionInProgress = false;\n                  if (getStorage('rhythmReadingPending') === 'true') {\n                    setStorage('rhythmReadingPending', 'false');\n                    self.start();\n                  }\n                }, 1500);\n              }\n              break;\n            }\n          }\n          target = target.parentNode;\n        }\n      });\n\n      // 监听键盘导航事件\n      document.addEventListener('keydown', function (e) {\n        // 检查是否是翻页快捷键\n        if (['ArrowLeft', 'ArrowRight', 'PageUp', 'PageDown'].includes(e.key)) {\n          if (self.active) {\n            console.log(`【节奏阅读】检测到键盘翻页: ${e.key}`);\n\n            // 保存状态到存储\n            setStorage('rhythmReadingActive', 'true');\n            setStorage('rhythmReadingPending', 'true');\n\n            // 标记页面转换开始\n            self.pageTransitionInProgress = true;\n\n            // 停止当前的阅读\n            self.stop(false);\n\n            // 添加延迟执行的监听器\n            setTimeout(() => {\n              self.pageTransitionInProgress = false;\n              if (getStorage('rhythmReadingPending') === 'true') {\n                setStorage('rhythmReadingPending', 'false');\n                self.start();\n              }\n            }, 1500);\n          }\n        }\n      });\n\n      // 添加popstate监听器捕获浏览器前进/后退导航\n      window.addEventListener('popstate', function () {\n        if (self.active) {\n          console.log(\"【节奏阅读】检测到历史导航事件\");\n\n          // 保存状态\n          setStorage('rhythmReadingActive', 'true');\n          setStorage('rhythmReadingPending', 'true');\n\n          // 标记页面转换开始\n          self.pageTransitionInProgress = true;\n\n          // 停止当前阅读\n          self.stop(false);\n\n          // 延迟恢复\n          setTimeout(() => {\n            self.pageTransitionInProgress = false;\n            if (getStorage('rhythmReadingPending') === 'true') {\n              setStorage('rhythmReadingPending', 'false');\n              self.start();\n            }\n          }, 1500);\n        }\n      });\n    }\n  };\n})();","map":{"version":3,"names":["React","useState","useRef","useEffect","pdfjsLib","pdfjsViewer","marked","pdfjs","GlobalWorkerOptions","workerSrc","version","window","currentPage","totalPages","changePage","eventTracker","mouseFollowHandlers","rhythmReaderGlobal","active","speed","console","log","rhythmReadingInitialized","setStorage","key","value","sessionStorage","setItem","localStorage","e","error","getStorage","getItem","rhythmReader","intervalId","currentIndex","readIndices","Set","charElements","pageTransitionInProgress","initializeTextNodes","contentContainer","document","querySelector","textNodes","findTextNodes","length","showNotification","forEach","node","text","nodeValue","trim","fragment","createDocumentFragment","i","char","span","createElement","textContent","className","dataset","rhythmIndex","String","whitespace","style","display","margin","padding","border","backgroundColor","appendChild","push","parentNode","replaceChild","element","childNodes","nodeType","Node","TEXT_NODE","ELEMENT_NODE","id","updateTextColors","index","color","fontWeight","has","background","moveToNextChar","add","clickNextPageButton","stop","scrollToCurrentChar","rect","getBoundingClientRect","lineHeight","parseInt","getComputedStyle","Math","max","height","isContainerScrollable","scrollHeight","clientHeight","includes","overflowY","containerRect","relativeTop","top","scrollTop","visibleTop","visibleBottom","scrollBy","behavior","viewportTop","scrollY","viewportBottom","innerHeight","absoluteTop","addSpeedSlider","slider","getElementById","remove","container","position","right","borderRadius","boxShadow","zIndex","alignItems","maxWidth","label","marginRight","input","type","min","step","width","valueDisplay","marginLeft","minWidth","self","addEventListener","newSpeed","clearInterval","setInterval","body","restoreOriginalText","charSpans","querySelectorAll","parentNodeMap","Map","parent","set","get","spans","sort","a","b","indexA","indexB","groups","currentGroup","prevIndex","previousSibling","group","map","join","textNode","createTextNode","removeChild","start","setTimeout","clear","hijackPageTurningFunctions","setupPageNavigationListeners","message","notification","left","transform","fontSize","_originalChangePage","page","wasActive","rhythmReadingActive","undefined","warn","something","err","target","tagName","getAttribute","toLowerCase","ariaLabel"],"sources":["D:/adhd-read-helper/src/App.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport * as pdfjsLib from 'pdfjs-dist';\r\nimport * as pdfjsViewer from 'pdfjs-dist/web/pdf_viewer';\r\nimport { marked } from 'marked'; // 需要安装: npm install marked\r\nimport './styles/Reader.css';\r\nimport { pdfjs } from 'pdfjs-dist';\r\n\r\n// 设置 PDF.js worker\r\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\r\n\r\n// 全局变量定义\r\nwindow.currentPage = 1;\r\nwindow.totalPages = 0;\r\nwindow.changePage = null;\r\n\r\n// 添加全局事件跟踪对象\r\nwindow.eventTracker = window.eventTracker || {\r\n  mouseFollowHandlers: []\r\n};\r\n\r\n// 全局变量，确保在页面切换后仍然保持状态\r\nwindow.rhythmReaderGlobal = window.rhythmReaderGlobal || {\r\n  active: false,\r\n  speed: 300\r\n};\r\n\r\n// 节奏阅读模式 - 确保手动翻页后也能自动恢复\r\n(function() {\r\n  console.log(\"正在初始化节奏阅读模式...\");\r\n  \r\n  // 确保只初始化一次\r\n  if (window.rhythmReadingInitialized) {\r\n    console.log(\"节奏阅读模式已经初始化过，跳过\");\r\n    return;\r\n  }\r\n  window.rhythmReadingInitialized = true;\r\n  \r\n  // 改进的存储函数，同时使用session和local storage提高可靠性\r\n  function setStorage(key, value) {\r\n    try {\r\n      sessionStorage.setItem(key, value);\r\n      localStorage.setItem(key, value);\r\n    } catch (e) {\r\n      console.error(\"无法写入存储\", e);\r\n    }\r\n  }\r\n  \r\n  function getStorage(key) {\r\n    try {\r\n      // 优先使用sessionStorage，这样更适合单次会话\r\n      return sessionStorage.getItem(key) || localStorage.getItem(key);\r\n    } catch (e) {\r\n      console.error(\"无法读取存储\", e);\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  // 状态变量和功能对象\r\n  const rhythmReader = {\r\n    active: false,\r\n    intervalId: null,\r\n    speed: 300,\r\n    currentIndex: 0,\r\n    readIndices: new Set(),\r\n    charElements: [],\r\n    pageTransitionInProgress: false,\r\n    \r\n    // 初始化文本节点\r\n    initializeTextNodes: function() {\r\n      console.log(\"【节奏阅读】初始化文本节点...\");\r\n      \r\n      // 重置字符元素数组\r\n      this.charElements = [];\r\n    \r\n      // 获取内容容器\r\n      const contentContainer = document.querySelector('.page-content');\r\n      if (!contentContainer) {\r\n        console.error(\"【节奏阅读】找不到内容容器\");\r\n        return false;\r\n      }\r\n    \r\n      // 查找所有文本节点并处理\r\n      const textNodes = [];\r\n      this.findTextNodes(contentContainer, textNodes);\r\n    \r\n      if (textNodes.length === 0) {\r\n        console.error(\"【节奏阅读】未找到文本节点\");\r\n        this.showNotification(\"无法启动节奏阅读：未找到文本内容\");\r\n        return false;\r\n      }\r\n    \r\n      console.log(`【节奏阅读】找到${textNodes.length}个文本节点`);\r\n    \r\n      // 为每个文本节点创建字符span\r\n      textNodes.forEach(node => {\r\n        const text = node.nodeValue;\r\n        if (!text || text.trim() === '') return;\r\n        \r\n        // 创建文档片段来存放字符span\r\n        const fragment = document.createDocumentFragment();\r\n        \r\n        // 为每个字符创建span\r\n        for (let i = 0; i < text.length; i++) {\r\n          const char = text[i];\r\n          const span = document.createElement('span');\r\n          span.textContent = char;\r\n          span.className = 'rhythm-char';\r\n          span.dataset.rhythmIndex = String(this.charElements.length);\r\n          \r\n          // 如果是空白字符，添加一个标志\r\n          if (char.trim() === '') {\r\n            span.dataset.whitespace = 'true';\r\n          }\r\n          \r\n          // 保持原始样式，不设置背景\r\n          span.style.display = 'inline';\r\n          span.style.margin = '0';\r\n          span.style.padding = '0';\r\n          span.style.border = 'none';\r\n          span.style.backgroundColor = 'transparent';\r\n          \r\n          fragment.appendChild(span);\r\n          this.charElements.push(span);\r\n        }\r\n        \r\n        // 替换原始节点\r\n        if (node.parentNode) {\r\n          node.parentNode.replaceChild(fragment, node);\r\n        }\r\n      });\r\n      \r\n      console.log(`【节奏阅读】总共创建${this.charElements.length}个字符span`);\r\n      return this.charElements.length > 0;\r\n    },\r\n  \r\n    // 递归查找所有文本节点\r\n    findTextNodes: function(element, textNodes) {\r\n      // 处理子节点\r\n      for (let i = 0; i < element.childNodes.length; i++) {\r\n        const node = element.childNodes[i];\r\n        \r\n        // 如果是文本节点且有内容\r\n        if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== '') {\r\n          textNodes.push(node);\r\n        } \r\n        // 如果是元素节点，递归处理\r\n        else if (node.nodeType === Node.ELEMENT_NODE) {\r\n          // 跳过读者UI元素\r\n          if (node.id === 'rhythm-speed-slider' || \r\n              node.id === 'rhythm-notification' ||\r\n              node.className === 'rhythm-char') {\r\n            continue;\r\n          }\r\n          this.findTextNodes(node, textNodes);\r\n        }\r\n      }\r\n    },\r\n  \r\n    // 更新文本颜色\r\n    updateTextColors: function() {\r\n      // 更新所有字符的颜色\r\n      this.charElements.forEach((span, index) => {\r\n        // 确定颜色\r\n        let color;\r\n        let fontWeight = 'inherit';\r\n        \r\n        if (index === this.currentIndex) {\r\n          color = '#00aa00'; // 当前阅读的字 - 绿色\r\n          fontWeight = 'bold';\r\n        } else if (index === this.currentIndex + 1 || index === this.currentIndex + 2) {\r\n          color = '#aaaaaa'; // 接下来两个字 - 淡灰色\r\n        } else if (this.readIndices.has(index)) {\r\n          color = '#ffffff'; // 已读字符 - 白色（表示已读）\r\n        } else {\r\n          color = 'rgba(160, 160, 160, 0.25)'; // 未读字符 - 非常淡的灰色（可见但不明显）\r\n        }\r\n        \r\n        span.style.color = color;\r\n        span.style.fontWeight = fontWeight;\r\n        \r\n        // 确保没有背景\r\n        span.style.backgroundColor = 'transparent';\r\n        span.style.background = 'none';\r\n      });\r\n    },\r\n  \r\n    // 移动到下一个字符\r\n    moveToNextChar: function() {\r\n      // 将当前字符标记为已读\r\n      this.readIndices.add(this.currentIndex);\r\n    \r\n      // 移动到下一个非空白字符\r\n      do {\r\n        this.currentIndex++;\r\n        \r\n        // 检查是否到达末尾\r\n        if (this.currentIndex >= this.charElements.length) {\r\n          console.log(\"【节奏阅读】已到达页尾，尝试翻页\");\r\n          \r\n          // 尝试点击下一页按钮\r\n          if (!this.clickNextPageButton()) {\r\n            // 如果没有找到下一页按钮，完全停止阅读\r\n            this.stop();\r\n          }\r\n          return;\r\n        }\r\n      } while (\r\n        this.currentIndex < this.charElements.length && \r\n        this.charElements[this.currentIndex] && \r\n        this.charElements[this.currentIndex].dataset.whitespace === 'true'\r\n      );\r\n    \r\n      // 更新颜色\r\n      this.updateTextColors();\r\n    \r\n      // 滚动到当前字符\r\n      this.scrollToCurrentChar();\r\n    },\r\n  \r\n    // 滚动到当前字符\r\n    scrollToCurrentChar: function() {\r\n      const span = this.charElements[this.currentIndex];\r\n      if (!span) return;\r\n    \r\n      const rect = span.getBoundingClientRect();\r\n      const contentContainer = document.querySelector('.page-content');\r\n    \r\n      // 估计行高\r\n      const lineHeight = parseInt(window.getComputedStyle(span).lineHeight) || \r\n                       Math.max(20, rect.height * 1.5);\r\n    \r\n      // 确定滚动容器\r\n      const isContainerScrollable = contentContainer && \r\n        contentContainer.scrollHeight > contentContainer.clientHeight &&\r\n        ['auto', 'scroll', 'overlay'].includes(window.getComputedStyle(contentContainer).overflowY);\r\n    \r\n      if (isContainerScrollable) {\r\n        // 容器滚动\r\n        const containerRect = contentContainer.getBoundingClientRect();\r\n        const relativeTop = rect.top - containerRect.top + contentContainer.scrollTop;\r\n        \r\n        const visibleTop = contentContainer.scrollTop;\r\n        const visibleBottom = visibleTop + contentContainer.clientHeight;\r\n        \r\n        if (relativeTop < visibleTop + lineHeight || relativeTop > visibleBottom - lineHeight) {\r\n          contentContainer.scrollBy({\r\n            top: lineHeight * 2 * (relativeTop > visibleBottom - lineHeight ? 1 : -1),\r\n            behavior: 'smooth'\r\n          });\r\n        }\r\n      } else {\r\n        // 窗口滚动\r\n        const viewportTop = window.scrollY;\r\n        const viewportBottom = viewportTop + window.innerHeight;\r\n        const absoluteTop = rect.top + window.scrollY;\r\n        \r\n        if (absoluteTop < viewportTop + lineHeight || absoluteTop > viewportBottom - lineHeight) {\r\n          window.scrollBy({\r\n            top: lineHeight * 2 * (absoluteTop > viewportBottom - lineHeight ? 1 : -1),\r\n            behavior: 'smooth'\r\n          });\r\n        }\r\n      }\r\n    },\r\n    \r\n    // 添加速度滑块\r\n    addSpeedSlider: function() {\r\n      let slider = document.getElementById('rhythm-speed-slider');\r\n      if (slider) slider.remove();\r\n      \r\n      const container = document.createElement('div');\r\n      container.id = 'rhythm-speed-slider';\r\n      container.style.position = 'fixed';\r\n      container.style.top = '70px';\r\n      container.style.right = '20px';\r\n      container.style.backgroundColor = 'white';\r\n      container.style.padding = '10px';\r\n      container.style.borderRadius = '5px';\r\n      container.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';\r\n      container.style.zIndex = '10000';\r\n      container.style.display = 'flex';\r\n      container.style.alignItems = 'center';\r\n      container.style.maxWidth = '300px';\r\n      \r\n      const label = document.createElement('label');\r\n      label.textContent = '速度: ';\r\n      label.style.marginRight = '8px';\r\n      container.appendChild(label);\r\n      \r\n      const input = document.createElement('input');\r\n      input.type = 'range';\r\n      input.min = '50';\r\n      input.max = '1000';\r\n      input.step = '50';\r\n      input.value = this.speed;\r\n      input.style.width = '120px';\r\n      \r\n      const valueDisplay = document.createElement('span');\r\n      valueDisplay.textContent = `${this.speed}ms`;\r\n      valueDisplay.style.marginLeft = '8px';\r\n      valueDisplay.style.minWidth = '60px';\r\n      \r\n      const self = this;\r\n      input.addEventListener('input', function() {\r\n        const newSpeed = parseInt(this.value);\r\n        self.speed = newSpeed;\r\n        valueDisplay.textContent = `${newSpeed}ms`;\r\n        \r\n        if (self.intervalId) {\r\n          clearInterval(self.intervalId);\r\n          self.intervalId = setInterval(() => self.moveToNextChar(), newSpeed);\r\n        }\r\n      });\r\n      \r\n      container.appendChild(input);\r\n      container.appendChild(valueDisplay);\r\n      document.body.appendChild(container);\r\n    },\r\n  \r\n    // 恢复原始文本\r\n    restoreOriginalText: function() {\r\n      // 获取所有已创建的字符span\r\n      const charSpans = document.querySelectorAll('.rhythm-char');\r\n      \r\n      // 按父节点分组\r\n      const parentNodeMap = new Map();\r\n      \r\n      charSpans.forEach(span => {\r\n        const parent = span.parentNode;\r\n        if (!parent) return;\r\n        \r\n        if (!parentNodeMap.has(parent)) {\r\n          parentNodeMap.set(parent, []);\r\n        }\r\n        parentNodeMap.get(parent).push(span);\r\n      });\r\n      \r\n      // 对每个父节点，将连续的字符span合并回文本节点\r\n      parentNodeMap.forEach((spans, parent) => {\r\n        if (spans.length === 0) return;\r\n        \r\n        // 排序spans确保顺序正确\r\n        spans.sort((a, b) => {\r\n          const indexA = parseInt(a.dataset.rhythmIndex || '0');\r\n          const indexB = parseInt(b.dataset.rhythmIndex || '0');\r\n          return indexA - indexB;\r\n        });\r\n        \r\n        // 根据连续性分组\r\n        const groups = [];\r\n        if (spans.length > 0) {\r\n          let currentGroup = [spans[0]];\r\n          \r\n          for (let i = 1; i < spans.length; i++) {\r\n            const prevIndex = parseInt(spans[i-1].dataset.rhythmIndex || '0');\r\n            const currentIndex = parseInt(spans[i].dataset.rhythmIndex || '0');\r\n            \r\n            if (currentIndex === prevIndex + 1 && spans[i].previousSibling === spans[i-1]) {\r\n              currentGroup.push(spans[i]);\r\n            } else {\r\n              groups.push(currentGroup);\r\n              currentGroup = [spans[i]];\r\n            }\r\n          }\r\n          \r\n          groups.push(currentGroup);\r\n        }\r\n        \r\n        // 对每个连续组替换为文本节点\r\n        groups.forEach(group => {\r\n          if (group.length === 0) return;\r\n          \r\n          try {\r\n            const text = group.map(span => span.textContent).join('');\r\n            const textNode = document.createTextNode(text);\r\n            \r\n            // 替换第一个span，然后移除其余的\r\n            if (group[0].parentNode === parent) {\r\n              parent.replaceChild(textNode, group[0]);\r\n              for (let i = 1; i < group.length; i++) {\r\n                if (group[i].parentNode === parent) {\r\n                  parent.removeChild(group[i]);\r\n                }\r\n              }\r\n            }\r\n          } catch (e) {\r\n            console.error(\"【节奏阅读】恢复文本时出错:\", e);\r\n          }\r\n        });\r\n      });\r\n      \r\n      // 清除字符元素数组\r\n      this.charElements = [];\r\n    },\r\n    \r\n    // 启动节奏阅读\r\n    start: function() {\r\n      console.log(\"【节奏阅读】启动中...\");\r\n      \r\n      // 检查是否正在进行页面转换\r\n      if (this.pageTransitionInProgress) {\r\n        console.log(\"【节奏阅读】页面转换正在进行中，延迟启动\");\r\n        setTimeout(() => this.start(), 500);\r\n        return;\r\n      }\r\n    \r\n      // 先停止已有的\r\n      this.stop(false);\r\n    \r\n      // 设置为活动状态\r\n      this.active = true;\r\n      setStorage('rhythmReadingActive', 'true');\r\n    \r\n      // 初始化文本\r\n      if (!this.initializeTextNodes()) {\r\n        console.error(\"【节奏阅读】无法初始化文本节点\");\r\n        return;\r\n      }\r\n\r\n      // 重要：始终从头开始阅读\r\n      this.currentIndex = 0;\r\n      this.readIndices.clear();\r\n      \r\n      // 添加速度滑块\r\n      this.addSpeedSlider();\r\n    \r\n      // 更新颜色\r\n      this.updateTextColors();\r\n    \r\n      // 滚动到开始位置\r\n      this.scrollToCurrentChar();\r\n    \r\n      // 设置阅读间隔\r\n      this.intervalId = setInterval(() => this.moveToNextChar(), this.speed);\r\n      \r\n      console.log(\"【节奏阅读】成功启动\");\r\n      \r\n      // 显示提示\r\n      this.showNotification(\"节奏阅读模式已启动\");\r\n      \r\n      // 劫持翻页函数 - 重要步骤\r\n      this.hijackPageTurningFunctions();\r\n      \r\n      // 设置页面导航事件监听\r\n      this.setupPageNavigationListeners();\r\n    },\r\n    \r\n    // 停止节奏阅读\r\n    stop: function(showNotification = true) {\r\n      if (this.intervalId) {\r\n        clearInterval(this.intervalId);\r\n        this.intervalId = null;\r\n      }\r\n      \r\n      if (this.active) {\r\n        console.log(\"【节奏阅读】停止中...\");\r\n        this.active = false;\r\n        \r\n        // 仅当不是因翻页而停止时才清除活动状态\r\n        if (!this.pageTransitionInProgress) {\r\n          setStorage('rhythmReadingActive', 'false');\r\n        }\r\n        \r\n        // 恢复原始文本\r\n        this.restoreOriginalText();\r\n        \r\n        // 移除速度滑块\r\n        const slider = document.getElementById('rhythm-speed-slider');\r\n        if (slider) slider.remove();\r\n        \r\n        if (showNotification) {\r\n          this.showNotification(\"节奏阅读模式已停止\");\r\n        }\r\n      }\r\n    },\r\n    \r\n    // 显示通知\r\n    showNotification: function(message) {\r\n      let notification = document.getElementById('rhythm-notification');\r\n      if (notification) notification.remove();\r\n      \r\n      notification = document.createElement('div');\r\n      notification.id = 'rhythm-notification';\r\n      notification.textContent = message;\r\n      notification.style.position = 'fixed';\r\n      notification.style.top = '50%';\r\n      notification.style.left = '50%';\r\n      notification.style.transform = 'translate(-50%, -50%)';\r\n      notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\r\n      notification.style.color = 'white';\r\n      notification.style.padding = '15px 25px';\r\n      notification.style.borderRadius = '5px';\r\n      notification.style.zIndex = '10001';\r\n      notification.style.fontSize = '18px';\r\n      \r\n      document.body.appendChild(notification);\r\n      \r\n      // 2秒后自动消失\r\n      setTimeout(() => {\r\n        if (notification && notification.parentNode) {\r\n          notification.parentNode.removeChild(notification);\r\n        }\r\n      }, 2000);\r\n    },\r\n    \r\n    // 劫持页面翻转函数 - 改进版本\r\n    hijackPageTurningFunctions: function() {\r\n      if (typeof window.changePage === 'function' && !window._originalChangePage) {\r\n        console.log(\"【节奏阅读】劫持changePage函数\");\r\n        window._originalChangePage = window.changePage;\r\n        \r\n        const self = this;\r\n        window.changePage = function(page) {\r\n          console.log(\"【节奏阅读】检测到changePage调用，参数:\", page);\r\n          \r\n          const wasActive = self.active;\r\n          self.pageTransitionInProgress = true;\r\n          \r\n          if (wasActive) {\r\n            self.stop(false);\r\n            setStorage('rhythmReadingActive', 'true'); \r\n            setStorage('rhythmReadingPending', 'true');\r\n            document.body.dataset.rhythmReadingActive = 'true';\r\n          }\r\n          \r\n          try {\r\n            if (page === undefined || page === null) {\r\n              console.warn('【节奏阅读】安全处理：page参数为空');\r\n              page = {};\r\n            }\r\n            \r\n            if (typeof page === 'object' && !page.something) {\r\n              console.log('【节奏阅读】添加空的something对象防止错误');\r\n              page.something = { active: false };\r\n            }\r\n            \r\n            window._originalChangePage(page);\r\n          } catch (err) {\r\n            console.error(\"【节奏阅读】翻页函数执行出错:\", err);\r\n            self.clickNextPageButton();\r\n          }\r\n          \r\n          setTimeout(() => {\r\n            self.pageTransitionInProgress = false;\r\n            \r\n            if (wasActive && getStorage('rhythmReadingPending') === 'true') {\r\n              setStorage('rhythmReadingPending', 'false');\r\n              console.log(\"【节奏阅读】翻页后重新启动\");\r\n              setTimeout(() => self.start(), 500);\r\n            }\r\n          }, 1000);\r\n        };\r\n      }\r\n    },\r\n    \r\n    // 设置页面导航事件监听 - 加强版\r\n    setupPageNavigationListeners: function() {\r\n      // 查找所有可能的翻页按钮\r\n      console.log(\"【节奏阅读】正在设置页面导航监听\");\r\n      \r\n      const self = this;\r\n      \r\n      // 使用事件委托来捕获所有可能的点击\r\n      document.addEventListener('click', function(e) {\r\n        // 检查点击的元素是否可能是翻页按钮\r\n        let target = e.target;\r\n        while (target && target !== document.body) {\r\n          // 检查是否是翻页元素\r\n          if (target.tagName === 'BUTTON' || target.tagName === 'A' || \r\n              target.getAttribute('role') === 'button') {\r\n            \r\n            const text = (target.textContent || '').trim().toLowerCase();\r\n            const ariaLabel = (target.getAttribute('aria-label') || '').toLowerCase();\r\n            \r\n            // 检查是否是翻页元素\r\n            if (text.includes('上一页') || text.includes('下一页') || \r\n                text.includes('prev') || text.includes('next') ||\r\n                ariaLabel.includes('page') || ariaLabel.includes('页') ||\r\n                text === '<' || text === '>' || text === '←' || text === '→') {\r\n              \r\n              if (self.active) {\r\n                console.log(`【节奏阅读】检测到可能的翻页元素点击: ${text || ariaLabel}`);\r\n                \r\n                // 标记页面转换开始\r\n                self.pageTransitionInProgress = true;\r\n                \r\n                // 保存状态到存储\r\n                setStorage('rhythmReadingActive', 'true');\r\n                setStorage('rhythmReadingPending', 'true');\r\n                document.body.dataset.rhythmReadingActive = 'true';\r\n                \r\n                // 停止当前的阅读\r\n                self.stop(false);\r\n                \r\n                // 添加延迟执行的监听器，确保数据在页面加载后恢复\r\n                setTimeout(() => {\r\n                  self.pageTransitionInProgress = false;\r\n                  \r\n                  if (getStorage('rhythmReadingPending') === 'true') {\r\n                    setStorage('rhythmReadingPending', 'false');\r\n                    self.start();\r\n                  }\r\n                }, 1500);\r\n              }\r\n              \r\n              break;\r\n            }\r\n          }\r\n          \r\n          target = target.parentNode;\r\n        }\r\n      });\r\n      \r\n      // 监听键盘导航事件\r\n      document.addEventListener('keydown', function(e) {\r\n        // 检查是否是翻页快捷键\r\n        if (['ArrowLeft', 'ArrowRight', 'PageUp', 'PageDown'].includes(e.key)) {\r\n          if (self.active) {\r\n            console.log(`【节奏阅读】检测到键盘翻页: ${e.key}`);\r\n            \r\n            // 保存状态到存储\r\n            setStorage('rhythmReadingActive', 'true');\r\n            setStorage('rhythmReadingPending', 'true');\r\n            \r\n            // 标记页面转换开始\r\n            self.pageTransitionInProgress = true;\r\n            \r\n            // 停止当前的阅读\r\n            self.stop(false);\r\n            \r\n            // 添加延迟执行的监听器\r\n            setTimeout(() => {\r\n              self.pageTransitionInProgress = false;\r\n              \r\n              if (getStorage('rhythmReadingPending') === 'true') {\r\n                setStorage('rhythmReadingPending', 'false');\r\n                self.start();\r\n              }\r\n            }, 1500);\r\n          }\r\n        }\r\n      });\r\n      \r\n      // 添加popstate监听器捕获浏览器前进/后退导航\r\n      window.addEventListener('popstate', function() {\r\n        if (self.active) {\r\n          console.log(\"【节奏阅读】检测到历史导航事件\");\r\n          \r\n          // 保存状态\r\n          setStorage('rhythmReadingActive', 'true');\r\n          setStorage('rhythmReadingPending', 'true');\r\n          \r\n          // 标记页面转换开始\r\n          self.pageTransitionInProgress = true;\r\n          \r\n          // 停止当前阅读\r\n          self.stop(false);\r\n          \r\n          // 延迟恢复\r\n          setTimeout(() => {\r\n            self.pageTransitionInProgress = false;\r\n            \r\n            if (getStorage('rhythmReadingPending') === 'true') {\r\n              setStorage('rhythmReadingPending', 'false');\r\n              self.start();\r\n            }\r\n          }, 1500);\r\n        }\r\n      });\r\n    },\r\n  };\r\n})(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}