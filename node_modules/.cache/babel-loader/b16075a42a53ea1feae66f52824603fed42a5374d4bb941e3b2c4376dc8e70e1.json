{"ast":null,"code":"import React, { useState, useRef, useEffect } from 'react';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport * as pdfjsViewer from 'pdfjs-dist/web/pdf_viewer';\nimport { marked } from 'marked'; // 需要安装: npm install marked\nimport './styles/Reader.css';\nimport { pdfjs } from 'pdfjs-dist';\n\n// 设置 PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n\n// 全局变量定义\nwindow.currentPage = 1;\nwindow.totalPages = 0;\nwindow.changePage = null;\n\n// 添加全局事件跟踪对象\nwindow.eventTracker = window.eventTracker || {\n  mouseFollowHandlers: []\n};\n\n// 全局变量，确保在页面切换后仍然保持状态\nwindow.rhythmReaderGlobal = window.rhythmReaderGlobal || {\n  active: false,\n  speed: 300\n};\n\n// 节奏阅读模式 - 确保手动翻页后也能自动恢复\n(function () {\n  console.log(\"正在初始化节奏阅读模式...\");\n\n  // 确保只初始化一次\n  if (window.rhythmReadingInitialized) {\n    console.log(\"节奏阅读模式已经初始化过，跳过\");\n    return;\n  }\n  window.rhythmReadingInitialized = true;\n\n  // 改进的存储函数，同时使用session和local storage提高可靠性\n  function setStorage(key, value) {\n    try {\n      sessionStorage.setItem(key, value);\n      localStorage.setItem(key, value);\n    } catch (e) {\n      console.error(\"无法写入存储\", e);\n    }\n  }\n  function getStorage(key) {\n    try {\n      // 优先使用sessionStorage，这样更适合单次会话\n      return sessionStorage.getItem(key) || localStorage.getItem(key);\n    } catch (e) {\n      console.error(\"无法读取存储\", e);\n      return null;\n    }\n  }\n\n  // 状态变量和功能对象\n  const rhythmReader = {\n    active: false,\n    intervalId: null,\n    speed: 300,\n    currentIndex: 0,\n    readIndices: new Set(),\n    charElements: [],\n    pageTransitionInProgress: false,\n    // 初始化文本节点\n    initializeTextNodes: function () {\n      console.log(\"【节奏阅读】初始化文本节点...\");\n\n      // 重置字符元素数组\n      this.charElements = [];\n\n      // 获取内容容器\n      const contentContainer = document.querySelector('.page-content');\n      if (!contentContainer) {\n        console.error(\"【节奏阅读】找不到内容容器\");\n        return false;\n      }\n\n      // 查找所有文本节点并处理\n      const textNodes = [];\n      this.findTextNodes(contentContainer, textNodes);\n      if (textNodes.length === 0) {\n        console.error(\"【节奏阅读】未找到文本节点\");\n        this.showNotification(\"无法启动节奏阅读：未找到文本内容\");\n        return false;\n      }\n      console.log(`【节奏阅读】找到${textNodes.length}个文本节点`);\n\n      // 为每个文本节点创建字符span\n      textNodes.forEach(node => {\n        const text = node.nodeValue;\n        if (!text || text.trim() === '') return;\n\n        // 创建文档片段来存放字符span\n        const fragment = document.createDocumentFragment();\n\n        // 为每个字符创建span\n        for (let i = 0; i < text.length; i++) {\n          const char = text[i];\n          const span = document.createElement('span');\n          span.textContent = char;\n          span.className = 'rhythm-char';\n          span.dataset.rhythmIndex = String(this.charElements.length);\n\n          // 如果是空白字符，添加一个标志\n          if (char.trim() === '') {\n            span.dataset.whitespace = 'true';\n          }\n\n          // 保持原始样式，不设置背景\n          span.style.display = 'inline';\n          span.style.margin = '0';\n          span.style.padding = '0';\n          span.style.border = 'none';\n          span.style.backgroundColor = 'transparent';\n          fragment.appendChild(span);\n          this.charElements.push(span);\n        }\n\n        // 替换原始节点\n        if (node.parentNode) {\n          node.parentNode.replaceChild(fragment, node);\n        }\n      });\n      console.log(`【节奏阅读】总共创建${this.charElements.length}个字符span`);\n      return this.charElements.length > 0;\n    },\n    // 递归查找所有文本节点\n    findTextNodes: function (element, textNodes) {\n      // 处理子节点\n      for (let i = 0; i < element.childNodes.length; i++) {\n        const node = element.childNodes[i];\n\n        // 如果是文本节点且有内容\n        if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== '') {\n          textNodes.push(node);\n        }\n        // 如果是元素节点，递归处理\n        else if (node.nodeType === Node.ELEMENT_NODE) {\n          // 跳过读者UI元素\n          if (node.id === 'rhythm-speed-slider' || node.id === 'rhythm-notification' || node.className === 'rhythm-char') {\n            continue;\n          }\n          this.findTextNodes(node, textNodes);\n        }\n      }\n    },\n    // 更新文本颜色\n    updateTextColors: function () {\n      // 更新所有字符的颜色\n      this.charElements.forEach((span, index) => {\n        // 确定颜色\n        let color;\n        let fontWeight = 'inherit';\n        if (index === this.currentIndex) {\n          color = '#00aa00'; // 当前阅读的字 - 绿色\n          fontWeight = 'bold';\n        } else if (index === this.currentIndex + 1 || index === this.currentIndex + 2) {\n          color = '#aaaaaa'; // 接下来两个字 - 淡灰色\n        } else if (this.readIndices.has(index)) {\n          color = '#ffffff'; // 已读字符 - 白色（表示已读）\n        } else {\n          color = 'rgba(160, 160, 160, 0.25)'; // 未读字符 - 非常淡的灰色（可见但不明显）\n        }\n        span.style.color = color;\n        span.style.fontWeight = fontWeight;\n\n        // 确保没有背景\n        span.style.backgroundColor = 'transparent';\n        span.style.background = 'none';\n      });\n    },\n    // 移动到下一个字符\n    moveToNextChar: function () {\n      // 将当前字符标记为已读\n      this.readIndices.add(this.currentIndex);\n\n      // 移动到下一个非空白字符\n      do {\n        this.currentIndex++;\n\n        // 检查是否到达末尾\n        if (this.currentIndex >= this.charElements.length) {\n          console.log(\"【节奏阅读】已到达页尾，尝试翻页\");\n\n          // 尝试点击下一页按钮\n          if (!this.clickNextPageButton()) {\n            // 如果没有找到下一页按钮，完全停止阅读\n            this.stop();\n          }\n          return;\n        }\n      } while (this.currentIndex < this.charElements.length && this.charElements[this.currentIndex] && this.charElements[this.currentIndex].dataset.whitespace === 'true');\n\n      // 更新颜色\n      this.updateTextColors();\n\n      // 滚动到当前字符\n      this.scrollToCurrentChar();\n    },\n    // 滚动到当前字符\n    scrollToCurrentChar: function () {\n      const span = this.charElements[this.currentIndex];\n      if (!span) return;\n      const rect = span.getBoundingClientRect();\n      const contentContainer = document.querySelector('.page-content');\n\n      // 估计行高\n      const lineHeight = parseInt(window.getComputedStyle(span).lineHeight) || Math.max(20, rect.height * 1.5);\n\n      // 确定滚动容器\n      const isContainerScrollable = contentContainer && contentContainer.scrollHeight > contentContainer.clientHeight && ['auto', 'scroll', 'overlay'].includes(window.getComputedStyle(contentContainer).overflowY);\n      if (isContainerScrollable) {\n        // 容器滚动\n        const containerRect = contentContainer.getBoundingClientRect();\n        const relativeTop = rect.top - containerRect.top + contentContainer.scrollTop;\n        const visibleTop = contentContainer.scrollTop;\n        const visibleBottom = visibleTop + contentContainer.clientHeight;\n        if (relativeTop < visibleTop + lineHeight || relativeTop > visibleBottom - lineHeight) {\n          contentContainer.scrollBy({\n            top: lineHeight * 2 * (relativeTop > visibleBottom - lineHeight ? 1 : -1),\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // 窗口滚动\n        const viewportTop = window.scrollY;\n        const viewportBottom = viewportTop + window.innerHeight;\n        const absoluteTop = rect.top + window.scrollY;\n        if (absoluteTop < viewportTop + lineHeight || absoluteTop > viewportBottom - lineHeight) {\n          window.scrollBy({\n            top: lineHeight * 2 * (absoluteTop > viewportBottom - lineHeight ? 1 : -1),\n            behavior: 'smooth'\n          });\n        }\n      }\n    },\n    // 添加速度滑块\n    addSpeedSlider: function () {\n      let slider = document.getElementById('rhythm-speed-slider');\n      if (slider) slider.remove();\n      const container = document.createElement('div');\n      container.id = 'rhythm-speed-slider';\n      container.style.position = 'fixed';\n      container.style.top = '70px';\n      container.style.right = '20px';\n      container.style.backgroundColor = 'white';\n      container.style.padding = '10px';\n      container.style.borderRadius = '5px';\n      container.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';\n      container.style.zIndex = '10000';\n      container.style.display = 'flex';\n      container.style.alignItems = 'center';\n      container.style.maxWidth = '300px';\n      const label = document.createElement('label');\n      label.textContent = '速度: ';\n      label.style.marginRight = '8px';\n      container.appendChild(label);\n      const input = document.createElement('input');\n      input.type = 'range';\n      input.min = '50';\n      input.max = '1000';\n      input.step = '50';\n      input.value = this.speed;\n      input.style.width = '120px';\n      const valueDisplay = document.createElement('span');\n      valueDisplay.textContent = `${this.speed}ms`;\n      valueDisplay.style.marginLeft = '8px';\n      valueDisplay.style.minWidth = '60px';\n      const self = this;\n      input.addEventListener('input', function () {\n        const newSpeed = parseInt(this.value);\n        self.speed = newSpeed;\n        valueDisplay.textContent = `${newSpeed}ms`;\n        if (self.intervalId) {\n          clearInterval(self.intervalId);\n          self.intervalId = setInterval(() => self.moveToNextChar(), newSpeed);\n        }\n      });\n      container.appendChild(input);\n      container.appendChild(valueDisplay);\n      document.body.appendChild(container);\n    },\n    // 恢复原始文本\n    restoreOriginalText: function () {\n      // 获取所有已创建的字符span\n      const charSpans = document.querySelectorAll('.rhythm-char');\n\n      // 按父节点分组\n      const parentNodeMap = new Map();\n      charSpans.forEach(span => {\n        const parent = span.parentNode;\n        if (!parent) return;\n        if (!parentNodeMap.has(parent)) {\n          parentNodeMap.set(parent, []);\n        }\n        parentNodeMap.get(parent).push(span);\n      });\n\n      // 对每个父节点，将连续的字符span合并回文本节点\n      parentNodeMap.forEach((spans, parent) => {\n        if (spans.length === 0) return;\n\n        // 排序spans确保顺序正确\n        spans.sort((a, b) => {\n          const indexA = parseInt(a.dataset.rhythmIndex || '0');\n          const indexB = parseInt(b.dataset.rhythmIndex || '0');\n          return indexA - indexB;\n        });\n\n        // 根据连续性分组\n        const groups = [];\n        if (spans.length > 0) {\n          let currentGroup = [spans[0]];\n          for (let i = 1; i < spans.length; i++) {\n            const prevIndex = parseInt(spans[i - 1].dataset.rhythmIndex || '0');\n            const currentIndex = parseInt(spans[i].dataset.rhythmIndex || '0');\n            if (currentIndex === prevIndex + 1 && spans[i].previousSibling === spans[i - 1]) {\n              currentGroup.push(spans[i]);\n            } else {\n              groups.push(currentGroup);\n              currentGroup = [spans[i]];\n            }\n          }\n          groups.push(currentGroup);\n        }\n\n        // 对每个连续组替换为文本节点\n        groups.forEach(group => {\n          if (group.length === 0) return;\n          try {\n            const text = group.map(span => span.textContent).join('');\n            const textNode = document.createTextNode(text);\n\n            // 替换第一个span，然后移除其余的\n            if (group[0].parentNode === parent) {\n              parent.replaceChild(textNode, group[0]);\n              for (let i = 1; i < group.length; i++) {\n                if (group[i].parentNode === parent) {\n                  parent.removeChild(group[i]);\n                }\n              }\n            }\n          } catch (e) {\n            console.error(\"【节奏阅读】恢复文本时出错:\", e);\n          }\n        });\n      });\n\n      // 清除字符元素数组\n      this.charElements = [];\n    }\n  };\n})();","map":{"version":3,"names":["React","useState","useRef","useEffect","pdfjsLib","pdfjsViewer","marked","pdfjs","GlobalWorkerOptions","workerSrc","version","window","currentPage","totalPages","changePage","eventTracker","mouseFollowHandlers","rhythmReaderGlobal","active","speed","console","log","rhythmReadingInitialized","setStorage","key","value","sessionStorage","setItem","localStorage","e","error","getStorage","getItem","rhythmReader","intervalId","currentIndex","readIndices","Set","charElements","pageTransitionInProgress","initializeTextNodes","contentContainer","document","querySelector","textNodes","findTextNodes","length","showNotification","forEach","node","text","nodeValue","trim","fragment","createDocumentFragment","i","char","span","createElement","textContent","className","dataset","rhythmIndex","String","whitespace","style","display","margin","padding","border","backgroundColor","appendChild","push","parentNode","replaceChild","element","childNodes","nodeType","Node","TEXT_NODE","ELEMENT_NODE","id","updateTextColors","index","color","fontWeight","has","background","moveToNextChar","add","clickNextPageButton","stop","scrollToCurrentChar","rect","getBoundingClientRect","lineHeight","parseInt","getComputedStyle","Math","max","height","isContainerScrollable","scrollHeight","clientHeight","includes","overflowY","containerRect","relativeTop","top","scrollTop","visibleTop","visibleBottom","scrollBy","behavior","viewportTop","scrollY","viewportBottom","innerHeight","absoluteTop","addSpeedSlider","slider","getElementById","remove","container","position","right","borderRadius","boxShadow","zIndex","alignItems","maxWidth","label","marginRight","input","type","min","step","width","valueDisplay","marginLeft","minWidth","self","addEventListener","newSpeed","clearInterval","setInterval","body","restoreOriginalText","charSpans","querySelectorAll","parentNodeMap","Map","parent","set","get","spans","sort","a","b","indexA","indexB","groups","currentGroup","prevIndex","previousSibling","group","map","join","textNode","createTextNode","removeChild"],"sources":["D:/adhd-read-helper/src/App.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport * as pdfjsLib from 'pdfjs-dist';\r\nimport * as pdfjsViewer from 'pdfjs-dist/web/pdf_viewer';\r\nimport { marked } from 'marked'; // 需要安装: npm install marked\r\nimport './styles/Reader.css';\r\nimport { pdfjs } from 'pdfjs-dist';\r\n\r\n// 设置 PDF.js worker\r\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\r\n\r\n// 全局变量定义\r\nwindow.currentPage = 1;\r\nwindow.totalPages = 0;\r\nwindow.changePage = null;\r\n\r\n// 添加全局事件跟踪对象\r\nwindow.eventTracker = window.eventTracker || {\r\n  mouseFollowHandlers: []\r\n};\r\n\r\n// 全局变量，确保在页面切换后仍然保持状态\r\nwindow.rhythmReaderGlobal = window.rhythmReaderGlobal || {\r\n  active: false,\r\n  speed: 300\r\n};\r\n\r\n// 节奏阅读模式 - 确保手动翻页后也能自动恢复\r\n(function() {\r\n  console.log(\"正在初始化节奏阅读模式...\");\r\n  \r\n  // 确保只初始化一次\r\n  if (window.rhythmReadingInitialized) {\r\n    console.log(\"节奏阅读模式已经初始化过，跳过\");\r\n    return;\r\n  }\r\n  window.rhythmReadingInitialized = true;\r\n  \r\n  // 改进的存储函数，同时使用session和local storage提高可靠性\r\n  function setStorage(key, value) {\r\n    try {\r\n      sessionStorage.setItem(key, value);\r\n      localStorage.setItem(key, value);\r\n    } catch (e) {\r\n      console.error(\"无法写入存储\", e);\r\n    }\r\n  }\r\n  \r\n  function getStorage(key) {\r\n    try {\r\n      // 优先使用sessionStorage，这样更适合单次会话\r\n      return sessionStorage.getItem(key) || localStorage.getItem(key);\r\n    } catch (e) {\r\n      console.error(\"无法读取存储\", e);\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  // 状态变量和功能对象\r\n  const rhythmReader = {\r\n    active: false,\r\n    intervalId: null,\r\n    speed: 300,\r\n    currentIndex: 0,\r\n    readIndices: new Set(),\r\n    charElements: [],\r\n    pageTransitionInProgress: false,\r\n    \r\n    // 初始化文本节点\r\n    initializeTextNodes: function() {\r\n      console.log(\"【节奏阅读】初始化文本节点...\");\r\n      \r\n      // 重置字符元素数组\r\n      this.charElements = [];\r\n    \r\n      // 获取内容容器\r\n      const contentContainer = document.querySelector('.page-content');\r\n      if (!contentContainer) {\r\n        console.error(\"【节奏阅读】找不到内容容器\");\r\n        return false;\r\n      }\r\n    \r\n      // 查找所有文本节点并处理\r\n      const textNodes = [];\r\n      this.findTextNodes(contentContainer, textNodes);\r\n    \r\n      if (textNodes.length === 0) {\r\n        console.error(\"【节奏阅读】未找到文本节点\");\r\n        this.showNotification(\"无法启动节奏阅读：未找到文本内容\");\r\n        return false;\r\n      }\r\n    \r\n      console.log(`【节奏阅读】找到${textNodes.length}个文本节点`);\r\n    \r\n      // 为每个文本节点创建字符span\r\n      textNodes.forEach(node => {\r\n        const text = node.nodeValue;\r\n        if (!text || text.trim() === '') return;\r\n        \r\n        // 创建文档片段来存放字符span\r\n        const fragment = document.createDocumentFragment();\r\n        \r\n        // 为每个字符创建span\r\n        for (let i = 0; i < text.length; i++) {\r\n          const char = text[i];\r\n          const span = document.createElement('span');\r\n          span.textContent = char;\r\n          span.className = 'rhythm-char';\r\n          span.dataset.rhythmIndex = String(this.charElements.length);\r\n          \r\n          // 如果是空白字符，添加一个标志\r\n          if (char.trim() === '') {\r\n            span.dataset.whitespace = 'true';\r\n          }\r\n          \r\n          // 保持原始样式，不设置背景\r\n          span.style.display = 'inline';\r\n          span.style.margin = '0';\r\n          span.style.padding = '0';\r\n          span.style.border = 'none';\r\n          span.style.backgroundColor = 'transparent';\r\n          \r\n          fragment.appendChild(span);\r\n          this.charElements.push(span);\r\n        }\r\n        \r\n        // 替换原始节点\r\n        if (node.parentNode) {\r\n          node.parentNode.replaceChild(fragment, node);\r\n        }\r\n      });\r\n      \r\n      console.log(`【节奏阅读】总共创建${this.charElements.length}个字符span`);\r\n      return this.charElements.length > 0;\r\n    },\r\n  \r\n    // 递归查找所有文本节点\r\n    findTextNodes: function(element, textNodes) {\r\n      // 处理子节点\r\n      for (let i = 0; i < element.childNodes.length; i++) {\r\n        const node = element.childNodes[i];\r\n        \r\n        // 如果是文本节点且有内容\r\n        if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== '') {\r\n          textNodes.push(node);\r\n        } \r\n        // 如果是元素节点，递归处理\r\n        else if (node.nodeType === Node.ELEMENT_NODE) {\r\n          // 跳过读者UI元素\r\n          if (node.id === 'rhythm-speed-slider' || \r\n              node.id === 'rhythm-notification' ||\r\n              node.className === 'rhythm-char') {\r\n            continue;\r\n          }\r\n          this.findTextNodes(node, textNodes);\r\n        }\r\n      }\r\n    },\r\n  \r\n    // 更新文本颜色\r\n    updateTextColors: function() {\r\n      // 更新所有字符的颜色\r\n      this.charElements.forEach((span, index) => {\r\n        // 确定颜色\r\n        let color;\r\n        let fontWeight = 'inherit';\r\n        \r\n        if (index === this.currentIndex) {\r\n          color = '#00aa00'; // 当前阅读的字 - 绿色\r\n          fontWeight = 'bold';\r\n        } else if (index === this.currentIndex + 1 || index === this.currentIndex + 2) {\r\n          color = '#aaaaaa'; // 接下来两个字 - 淡灰色\r\n        } else if (this.readIndices.has(index)) {\r\n          color = '#ffffff'; // 已读字符 - 白色（表示已读）\r\n        } else {\r\n          color = 'rgba(160, 160, 160, 0.25)'; // 未读字符 - 非常淡的灰色（可见但不明显）\r\n        }\r\n        \r\n        span.style.color = color;\r\n        span.style.fontWeight = fontWeight;\r\n        \r\n        // 确保没有背景\r\n        span.style.backgroundColor = 'transparent';\r\n        span.style.background = 'none';\r\n      });\r\n    },\r\n  \r\n    // 移动到下一个字符\r\n    moveToNextChar: function() {\r\n      // 将当前字符标记为已读\r\n      this.readIndices.add(this.currentIndex);\r\n    \r\n      // 移动到下一个非空白字符\r\n      do {\r\n        this.currentIndex++;\r\n        \r\n        // 检查是否到达末尾\r\n        if (this.currentIndex >= this.charElements.length) {\r\n          console.log(\"【节奏阅读】已到达页尾，尝试翻页\");\r\n          \r\n          // 尝试点击下一页按钮\r\n          if (!this.clickNextPageButton()) {\r\n            // 如果没有找到下一页按钮，完全停止阅读\r\n            this.stop();\r\n          }\r\n          return;\r\n        }\r\n      } while (\r\n        this.currentIndex < this.charElements.length && \r\n        this.charElements[this.currentIndex] && \r\n        this.charElements[this.currentIndex].dataset.whitespace === 'true'\r\n      );\r\n    \r\n      // 更新颜色\r\n      this.updateTextColors();\r\n    \r\n      // 滚动到当前字符\r\n      this.scrollToCurrentChar();\r\n    },\r\n  \r\n    // 滚动到当前字符\r\n    scrollToCurrentChar: function() {\r\n      const span = this.charElements[this.currentIndex];\r\n      if (!span) return;\r\n    \r\n      const rect = span.getBoundingClientRect();\r\n      const contentContainer = document.querySelector('.page-content');\r\n    \r\n      // 估计行高\r\n      const lineHeight = parseInt(window.getComputedStyle(span).lineHeight) || \r\n                       Math.max(20, rect.height * 1.5);\r\n    \r\n      // 确定滚动容器\r\n      const isContainerScrollable = contentContainer && \r\n        contentContainer.scrollHeight > contentContainer.clientHeight &&\r\n        ['auto', 'scroll', 'overlay'].includes(window.getComputedStyle(contentContainer).overflowY);\r\n    \r\n      if (isContainerScrollable) {\r\n        // 容器滚动\r\n        const containerRect = contentContainer.getBoundingClientRect();\r\n        const relativeTop = rect.top - containerRect.top + contentContainer.scrollTop;\r\n        \r\n        const visibleTop = contentContainer.scrollTop;\r\n        const visibleBottom = visibleTop + contentContainer.clientHeight;\r\n        \r\n        if (relativeTop < visibleTop + lineHeight || relativeTop > visibleBottom - lineHeight) {\r\n          contentContainer.scrollBy({\r\n            top: lineHeight * 2 * (relativeTop > visibleBottom - lineHeight ? 1 : -1),\r\n            behavior: 'smooth'\r\n          });\r\n        }\r\n      } else {\r\n        // 窗口滚动\r\n        const viewportTop = window.scrollY;\r\n        const viewportBottom = viewportTop + window.innerHeight;\r\n        const absoluteTop = rect.top + window.scrollY;\r\n        \r\n        if (absoluteTop < viewportTop + lineHeight || absoluteTop > viewportBottom - lineHeight) {\r\n          window.scrollBy({\r\n            top: lineHeight * 2 * (absoluteTop > viewportBottom - lineHeight ? 1 : -1),\r\n            behavior: 'smooth'\r\n          });\r\n        }\r\n      }\r\n    },\r\n    \r\n    // 添加速度滑块\r\n    addSpeedSlider: function() {\r\n      let slider = document.getElementById('rhythm-speed-slider');\r\n      if (slider) slider.remove();\r\n      \r\n      const container = document.createElement('div');\r\n      container.id = 'rhythm-speed-slider';\r\n      container.style.position = 'fixed';\r\n      container.style.top = '70px';\r\n      container.style.right = '20px';\r\n      container.style.backgroundColor = 'white';\r\n      container.style.padding = '10px';\r\n      container.style.borderRadius = '5px';\r\n      container.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';\r\n      container.style.zIndex = '10000';\r\n      container.style.display = 'flex';\r\n      container.style.alignItems = 'center';\r\n      container.style.maxWidth = '300px';\r\n      \r\n      const label = document.createElement('label');\r\n      label.textContent = '速度: ';\r\n      label.style.marginRight = '8px';\r\n      container.appendChild(label);\r\n      \r\n      const input = document.createElement('input');\r\n      input.type = 'range';\r\n      input.min = '50';\r\n      input.max = '1000';\r\n      input.step = '50';\r\n      input.value = this.speed;\r\n      input.style.width = '120px';\r\n      \r\n      const valueDisplay = document.createElement('span');\r\n      valueDisplay.textContent = `${this.speed}ms`;\r\n      valueDisplay.style.marginLeft = '8px';\r\n      valueDisplay.style.minWidth = '60px';\r\n      \r\n      const self = this;\r\n      input.addEventListener('input', function() {\r\n        const newSpeed = parseInt(this.value);\r\n        self.speed = newSpeed;\r\n        valueDisplay.textContent = `${newSpeed}ms`;\r\n        \r\n        if (self.intervalId) {\r\n          clearInterval(self.intervalId);\r\n          self.intervalId = setInterval(() => self.moveToNextChar(), newSpeed);\r\n        }\r\n      });\r\n      \r\n      container.appendChild(input);\r\n      container.appendChild(valueDisplay);\r\n      document.body.appendChild(container);\r\n    },\r\n  \r\n    // 恢复原始文本\r\n    restoreOriginalText: function() {\r\n      // 获取所有已创建的字符span\r\n      const charSpans = document.querySelectorAll('.rhythm-char');\r\n      \r\n      // 按父节点分组\r\n      const parentNodeMap = new Map();\r\n      \r\n      charSpans.forEach(span => {\r\n        const parent = span.parentNode;\r\n        if (!parent) return;\r\n        \r\n        if (!parentNodeMap.has(parent)) {\r\n          parentNodeMap.set(parent, []);\r\n        }\r\n        parentNodeMap.get(parent).push(span);\r\n      });\r\n      \r\n      // 对每个父节点，将连续的字符span合并回文本节点\r\n      parentNodeMap.forEach((spans, parent) => {\r\n        if (spans.length === 0) return;\r\n        \r\n        // 排序spans确保顺序正确\r\n        spans.sort((a, b) => {\r\n          const indexA = parseInt(a.dataset.rhythmIndex || '0');\r\n          const indexB = parseInt(b.dataset.rhythmIndex || '0');\r\n          return indexA - indexB;\r\n        });\r\n        \r\n        // 根据连续性分组\r\n        const groups = [];\r\n        if (spans.length > 0) {\r\n          let currentGroup = [spans[0]];\r\n          \r\n          for (let i = 1; i < spans.length; i++) {\r\n            const prevIndex = parseInt(spans[i-1].dataset.rhythmIndex || '0');\r\n            const currentIndex = parseInt(spans[i].dataset.rhythmIndex || '0');\r\n            \r\n            if (currentIndex === prevIndex + 1 && spans[i].previousSibling === spans[i-1]) {\r\n              currentGroup.push(spans[i]);\r\n            } else {\r\n              groups.push(currentGroup);\r\n              currentGroup = [spans[i]];\r\n            }\r\n          }\r\n          \r\n          groups.push(currentGroup);\r\n        }\r\n        \r\n        // 对每个连续组替换为文本节点\r\n        groups.forEach(group => {\r\n          if (group.length === 0) return;\r\n          \r\n          try {\r\n            const text = group.map(span => span.textContent).join('');\r\n            const textNode = document.createTextNode(text);\r\n            \r\n            // 替换第一个span，然后移除其余的\r\n            if (group[0].parentNode === parent) {\r\n              parent.replaceChild(textNode, group[0]);\r\n              for (let i = 1; i < group.length; i++) {\r\n                if (group[i].parentNode === parent) {\r\n                  parent.removeChild(group[i]);\r\n                }\r\n              }\r\n            }\r\n          } catch (e) {\r\n            console.error(\"【节奏阅读】恢复文本时出错:\", e);\r\n          }\r\n        });\r\n      });\r\n      \r\n      // 清除字符元素数组\r\n      this.charElements = [];\r\n    },\r\n  };\r\n})(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}